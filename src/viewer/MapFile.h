#ifndef __MAP_FILE_H__
#define __MAP_FILE_H__


#include "Feature.h"
#include "Raster.h"


#include "Database.h"
#include "Projection.h"
#include "Cache.h"
#include "Dictionary.h"
#include "XmlDocument.h"

#include <map>

class ConnectionPool ;
class ProjectionCache ;
class RasterTile ;

enum LayerType { Points, Lines, Polygons } ;

using std::string ;
using std::vector ;
using std::map ;

namespace sld {
class FeatureTypeStyle ;
typedef boost::shared_ptr<FeatureTypeStyle> FeatureTypeStylePtr ;
}

class LayerInfo {

public:
    string name, geomColumn, type ;
    int srid ;
    AttributeCollectionPtr attrs ;
    vector<sld::FeatureTypeStylePtr> fts ;
};

class BBox {

public:

    BBox() {}

    BBox(double minx_, double miny_, double maxx_, double maxy_, int srid_ = 4326):
        minx(minx_), miny(miny_), maxx(maxx_), maxy(maxy_), srid(srid_) {
    }

    double width() const { return maxx - minx ; }
    double height() const { return maxy - miny ; }

    bool transform(int target_srid, BBox &q, ProjectionCache &prj) const ;

    double minx, miny, maxx, maxy ;
    int srid ;
};

struct POI {
    double lat_, lon_ ; // coordinates
    Dictionary tags_ ; // returned tags
    double distance_ ;  // distance from search center
};


class MapDescription {
public:

    MapDescription(): tile_size_(256), bg_color_("white"), min_z_(0), max_z_(12) {}

    bool parseXml(const XmlDocument &doc) ;

    BBox bbox_ ;
    string name_ ;
    string description_ ;
    string attribution_ ;
    size_t min_z_, max_z_, tile_size_ ;
    string bg_color_ ;
    string resource_path_ ;
    string layers_ ;
    string styles_ ;
    string url_ ;
    string image_format_ ;
};

typedef Cache<int, boost::shared_ptr<RasterTile> > TileCache ;


class MapFile {
public:
    MapFile() ;
    ~MapFile() ;

    // Open for reading

    bool open(const string &filePath) ;

     // Get bounding box

    void getBoundingBox(double bbox[4]) const ;
    bool getBoundingBox(BBox &rbox, int target_srid) const;
    void getBoundingBoxFromGeometry(const string &layer, double bbox[4]) const ;
    void getBoundingBoxFromGeometry(double bbox[4]) const ;

    // Get the assigned geometry column for this layer

    string getLayerGeometryColumn(const string &) const ;

    // Get attributes of features in the layer

    void getLayerAttributes(const string &layerName, vector<string> &names) const ;

    // Get all geometry columns in the layer

    void getLayerGeometryColumns(const string &layerName, vector<string> &names) const ;

    // Get layer info

    bool getLayerInfo(const string &layerName, LayerInfo &info);

    string getFileName() const { return fileName ; }

    // Get proj4 string associated with the given srid

    string getProj4SRID(int srid) const;

    // Get handle to database

    SQLite::Database &handle() const { return *db_ ; }

    // various data source may be inserted in the database using ogr/gdal
    // ogr2ogr -update -overwrite -nln corine_hellas -nlt POLYGON -f SQLite -select level1,level2,level3 -s_srs EPSG:4326 -lco FORMAT=SPATIALITE -spat 23.590000 40.435000 23.830000 40.675000 map ~/GPS/mapping/corine_hellas.shp

    // Equivalently rasters are provided using rasterlite tools
    // rasterlite_load -d ~/tmp/map -v -T hillshade -f maps/stratoniko/images/hillshade.tif -i PNG
    // rasterlite_pyramid -d ~/tmp/map -T hillshade -v
    // rasterlite_topmost -d ~/tmp/map -T hillshade -v

    bool hasLayer(const std::string &layerName);

    // makes a bbox spatial query

    bool queryFeatures(FeatureCollection &col,  // output collection of features found
                       const LayerInfo &info,   // layer info
                       int target_srid,         // the srid of output geometries
                       const string &condition, // a WHERE SQlite expression to pass to the query
                       const BBox &box          // the request bounding box
                       )  ;

    // query rasterlite layer image. it should be in the same srid as target_srid

    bool queryRasterlite(RasterData &data,        // output raster image
                     const LayerInfo &info,   // layer info
                     int target_srid,         // the srid of output geometries
                     double res,              // raster resolution
                     const BBox &box          // the request bounding box
                     ) ;

    // query external tiles generated by gdal2tiles.py (default parameters are assumed: tilesize = 256x256, profile=mercator)

    bool queryTiles(RasterData &data,        // output raster image
                     const LayerInfo &info,   // layer info
                     int target_srid,         // the srid of map
                     double res,              // raster resolution
                     const BBox &box          // the request bounding box
                     ) ;

    // query points of interest

    bool queryPOIs(
                   const string &layerName,
                   vector<POI> &pois,
                   const string &condition,         // SQL condition to filter POIs (e.g. by category)
                   const string &match,             // string to search for (see FTS4 docs)
                   BBox *bbox = 0,                  // optional bounding box to constrain search
                   double dist_threshold = 0.0,     // distance threshold in meters (if zero then no distance thresholding is performed)
                   double lon = 0, double lat = 0,  // coordinates of center point used to measure distances from (results are sorted based on distance)
                   int prj_srid = 3857              // srid used for measuring distances
                   );

    ProjectionCache &getProjectionCache() const {
        return *pj_cache_ ;
    }


    string readResourceFile(const string &path) const ;

    const MapDescription &getMetaData() const {
        return desc_ ;
    }

private:

    bool readMetaData() ;

    string makeBBoxQuery(const std::string &tableName, const AttributeCollection &attrs, const std::string &geomColumn,
                         int t_srid, const std::string &condition, const BBox &bbox, bool z_order=false);

    bool hasTable(const std::string &tableName) const ;

private:

    friend class Renderer ;
    friend class TileSet ;

    SQLite::Database *db_ ;

    string fileName ;
    ProjectionCache *pj_cache_ ;
    std::map<std::string, LayerInfo> layerCache ;

    TileCache tileCache ;
    MapDescription desc_ ;


};



#endif
